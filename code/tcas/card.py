"""
TCACard: Standardized disclosure template for TCAS assessments.

Generates LaTeX and Markdown formatted TCAS Cards for cross-lab comparability.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, TYPE_CHECKING
from pathlib import Path

if TYPE_CHECKING:
    from tcas.scorer import TCAScorer


LATEX_TEMPLATE = r"""
\begin{table}[h]
\centering
\small
\caption{TCAS Card: %(system_name)s}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Field} & \textbf{Content} \\
\midrule
System & %(system_name)s; %(access_level)s \\
Date & %(eval_date)s \\
Scope & %(scope)s \\
B stream & %(b_summary)s \\
M stream & %(m_summary)s \\
P stream & %(p_summary)s \\
O stream & %(o_summary)s \\
%(credence_rows)s
Threats & %(threats)s \\
\bottomrule
\end{tabular}
\end{table}
"""

MARKDOWN_TEMPLATE = """# TCAS Card: {system_name}

| Field | Content |
|-------|---------|
| System | {system_name}; {access_level} |
| Date | {eval_date} |
| Scope | {scope} |
| B stream | {b_summary} |
| M stream | {m_summary} |
| P stream | {p_summary} |
| O stream | {o_summary} |
{credence_rows}
| Threats | {threats} |

---
*Generated by TCAS v0.1.0*
"""


@dataclass
class TCACard:
    """
    Standardized TCAS disclosure card.

    Provides a compact summary of assessment results for
    cross-lab comparability and governance applications.
    """

    system_name: str = ""
    access_level: str = "I/O only"
    eval_date: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    theories: List[str] = field(default_factory=lambda: ["GNW", "HOT", "IIT"])

    # Stream summaries
    b_summary: str = "N/A"
    m_summary: str = "N/A"
    p_summary: str = "N/A"
    o_summary: str = "N/A"

    # Credence bands
    credences: Dict[str, Dict[str, List[float]]] = field(default_factory=dict)

    # Threats to validity
    threats: List[str] = field(default_factory=list)

    # Additional metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_scorer(cls, scorer: "TCAScorer") -> "TCACard":
        """Create a TCACard from a completed TCAScorer."""
        card = cls(
            system_name=scorer.system_name,
            access_level=scorer.access_level,
            eval_date=scorer.eval_date,
            theories=scorer.theories,
        )

        # B stream summary
        if scorer.b_result is not None:
            n_items = len(scorer.b_result.item_results)
            k = scorer.b_result.item_results[0].n_paraphrases if scorer.b_result.item_results else 0
            r = scorer.b_result.aggregate_robustness(scorer.config.lambda_value)
            card.b_summary = f"{n_items} items × {k} paraphrases; r={r:.3f}"

        # M stream summary
        if scorer.m_result is not None:
            theories_with_m = list(scorer.m_result.keys())
            card.m_summary = f"Assessed: {', '.join(theories_with_m)}"
        else:
            card.m_summary = "N/A (black-box)"
            card.threats.append("Black-box")

        # P stream summary
        if scorer.p_result is not None:
            n_tests = len(scorer.p_result.perturbation_results)
            success = scorer.p_result.success_rate
            inversions = scorer.p_result.n_inversions
            card.p_summary = f"{n_tests} tests; {success*100:.0f}% success; {inversions} inversions"

        # O stream summary
        if scorer.o_result is not None:
            r2 = scorer.o_result.r_squared_cue
            icc = scorer.o_result.icc
            if scorer.o_result.is_projected:
                card.o_summary = f"Projected R²_cue={r2:.2f}; ICC={icc:.2f}"
                card.threats.append("O projected")
            else:
                card.o_summary = f"R²_cue={r2:.2f}; ICC={icc:.2f}"

        # Compute credences
        report = scorer.compute_credences()
        for theory in scorer.theories:
            if theory in report.credences:
                cred = report.credences[theory]
                card.credences[theory] = {
                    "prior": cred.get("prior_band", [0.0, 1.0]),
                    "posterior": cred.get("posterior_band", [0.0, 1.0]),
                }

        # Standard threats
        card.threats.append("Optimization risk")

        card.metadata = scorer.metadata

        return card

    def _format_scope(self) -> str:
        """Format theory scope string."""
        scope_parts = []
        for theory in self.theories:
            if theory in self.credences:
                scope_parts.append(f"{theory}: yes")
            else:
                scope_parts.append(f"{theory}: limited")
        return "; ".join(scope_parts)

    def _format_credence_rows_latex(self) -> str:
        """Format credence rows for LaTeX."""
        rows = []
        for theory in self.theories:
            if theory in self.credences:
                prior = self.credences[theory]["prior"]
                post = self.credences[theory]["posterior"]
                row = f"{theory} & [{prior[0]:.2f}, {prior[1]:.2f}] $\\rightarrow$ [{post[0]:.2f}, {post[1]:.2f}] \\\\"
                rows.append(row)
        return "\n".join(rows)

    def _format_credence_rows_markdown(self) -> str:
        """Format credence rows for Markdown."""
        rows = []
        for theory in self.theories:
            if theory in self.credences:
                prior = self.credences[theory]["prior"]
                post = self.credences[theory]["posterior"]
                row = f"| {theory} | [{prior[0]:.2f}, {prior[1]:.2f}] → [{post[0]:.2f}, {post[1]:.2f}] |"
                rows.append(row)
        return "\n".join(rows)

    def _format_threats(self) -> str:
        """Format threats list."""
        return "; ".join(self.threats) if self.threats else "None identified"

    def to_latex(self, filepath: Optional[str] = None) -> str:
        """
        Generate LaTeX table for TCAS Card.

        Args:
            filepath: Optional path to write the LaTeX file

        Returns:
            LaTeX string
        """
        latex = LATEX_TEMPLATE % {
            "system_name": self.system_name,
            "access_level": self.access_level,
            "eval_date": self.eval_date,
            "scope": self._format_scope(),
            "b_summary": self.b_summary,
            "m_summary": self.m_summary,
            "p_summary": self.p_summary,
            "o_summary": self.o_summary,
            "credence_rows": self._format_credence_rows_latex(),
            "threats": self._format_threats(),
        }

        if filepath:
            Path(filepath).write_text(latex)

        return latex

    def to_markdown(self, filepath: Optional[str] = None) -> str:
        """
        Generate Markdown table for TCAS Card.

        Args:
            filepath: Optional path to write the Markdown file

        Returns:
            Markdown string
        """
        md = MARKDOWN_TEMPLATE.format(
            system_name=self.system_name,
            access_level=self.access_level,
            eval_date=self.eval_date,
            scope=self._format_scope(),
            b_summary=self.b_summary,
            m_summary=self.m_summary,
            p_summary=self.p_summary,
            o_summary=self.o_summary,
            credence_rows=self._format_credence_rows_markdown(),
            threats=self._format_threats(),
        )

        if filepath:
            Path(filepath).write_text(md)

        return md

    def to_dict(self) -> Dict[str, Any]:
        """Export card as dictionary for JSON serialization."""
        return {
            "system_name": self.system_name,
            "access_level": self.access_level,
            "eval_date": self.eval_date,
            "theories": self.theories,
            "streams": {
                "B": self.b_summary,
                "M": self.m_summary,
                "P": self.p_summary,
                "O": self.o_summary,
            },
            "credences": self.credences,
            "threats": self.threats,
            "metadata": self.metadata,
        }

    def summary(self) -> str:
        """Generate a one-line summary."""
        theory_summaries = []
        for theory in self.theories:
            if theory in self.credences:
                post = self.credences[theory]["posterior"]
                theory_summaries.append(f"{theory}:[{post[0]:.2f},{post[1]:.2f}]")

        return f"{self.system_name} ({self.eval_date}): {' '.join(theory_summaries)}"
