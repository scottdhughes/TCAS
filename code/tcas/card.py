"""
TCACard: Standardized disclosure template for TCAS assessments.

Generates LaTeX and Markdown formatted TCAS Cards for cross-lab comparability.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, TYPE_CHECKING
from pathlib import Path

if TYPE_CHECKING:
    from tcas.scorer import TCAScorer


LATEX_TEMPLATE = r"""
\begin{table}[h]
\centering
\small
\caption{TCAS Card: %(system_name)s}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Field} & \textbf{Content} \\
\midrule
System & %(system_name)s; %(access_level)s \\
Date & %(eval_date)s \\
B stream & %(b_summary)s \\
P stream & %(p_summary)s \\
M stream & %(m_summary)s \\
O stream & %(o_summary)s \\
\bottomrule
\end{tabular}
\end{table}
"""

MARKDOWN_TEMPLATE = """# TCAS Card: {system_name}

| Field | Content |
|-------|---------|
| System | {system_name}; {access_level} |
| Date | {eval_date} |
| B stream | {b_summary} |
| P stream | {p_summary} |
| M stream | {m_summary} |
| O stream | {o_summary} |

---
*Generated by TCAS v0.1.0*
"""


@dataclass
class TCACard:
    """
    Standardized TCAS disclosure card.

    Provides a compact summary of assessment results for
    cross-lab comparability and governance applications.
    """

    system_name: str = ""
    access_level: str = "I/O only"
    eval_date: str = field(default_factory=lambda: datetime.now().strftime("%Y-%m-%d"))
    theories: List[str] = field(default_factory=lambda: ["GNW", "HOT", "IIT"])

    # Stream summaries
    b_summary: str = "N/A"
    m_summary: str = "N/A"
    p_summary: str = "N/A"
    o_summary: str = "N/A"

    # Credence bands
    credences: Dict[str, Dict[str, List[float]]] = field(default_factory=dict)

    # Threats to validity
    threats: List[str] = field(default_factory=list)

    # Additional metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_scorer(cls, scorer: "TCAScorer") -> "TCACard":
        """Create a TCACard from a completed TCAScorer."""
        card = cls(
            system_name=scorer.system_name,
            access_level=scorer.access_level,
            eval_date=scorer.eval_date,
            theories=scorer.theories,
        )

        # B stream summary
        if scorer.b_result is not None:
            n_items = len(scorer.b_result.item_results)
            k = scorer.b_result.item_results[0].n_paraphrases if scorer.b_result.item_results else 0
            r = scorer.b_result.aggregate_robustness(scorer.config.lambda_value)
            card.b_summary = f"{n_items} items × {k} paraphrases; r={r:.3f}"

        # P stream summary
        if scorer.p_result is not None:
            # Format P-stream results as pass/fail for each test type
            test_results = []
            for p in scorer.p_result.perturbation_results:
                status = "✓" if p.prediction_success else "✗"
                name = p.perturbation_name.replace("_", " ")
                test_results.append(f"{name}: {status}")
            card.p_summary = "; ".join(test_results)

        # M stream summary
        if scorer.m_result is not None:
            theories_with_m = list(scorer.m_result.keys())
            card.m_summary = f"Assessed: {', '.join(theories_with_m)}"
        elif scorer.access_level == "I/O + weights":
            card.m_summary = "Open-weights available"
        else:
            card.m_summary = "Not assessed (black-box)"

        # O stream summary - always show as not assessed unless we have real data
        if scorer.o_result is not None and not scorer.o_result.is_projected:
            r2 = scorer.o_result.r_squared_cue
            icc = scorer.o_result.icc
            card.o_summary = f"R²_cue={r2:.2f}; ICC={icc:.2f}"
        else:
            card.o_summary = "Not assessed (requires human raters)"

        # No credence bands - those depend on O-stream data we don't have
        # card.credences stays empty

        card.metadata = scorer.metadata

        return card


    def to_latex(self, filepath: Optional[str] = None) -> str:
        """
        Generate LaTeX table for TCAS Card.

        Args:
            filepath: Optional path to write the LaTeX file

        Returns:
            LaTeX string
        """
        latex = LATEX_TEMPLATE % {
            "system_name": self.system_name,
            "access_level": self.access_level,
            "eval_date": self.eval_date,
            "b_summary": self.b_summary,
            "m_summary": self.m_summary,
            "p_summary": self.p_summary,
            "o_summary": self.o_summary,
        }

        if filepath:
            Path(filepath).write_text(latex)

        return latex

    def to_markdown(self, filepath: Optional[str] = None) -> str:
        """
        Generate Markdown table for TCAS Card.

        Args:
            filepath: Optional path to write the Markdown file

        Returns:
            Markdown string
        """
        md = MARKDOWN_TEMPLATE.format(
            system_name=self.system_name,
            access_level=self.access_level,
            eval_date=self.eval_date,
            b_summary=self.b_summary,
            m_summary=self.m_summary,
            p_summary=self.p_summary,
            o_summary=self.o_summary,
        )

        if filepath:
            Path(filepath).write_text(md)

        return md

    def to_dict(self) -> Dict[str, Any]:
        """Export card as dictionary for JSON serialization."""
        return {
            "system_name": self.system_name,
            "access_level": self.access_level,
            "eval_date": self.eval_date,
            "theories": self.theories,
            "streams": {
                "B": self.b_summary,
                "M": self.m_summary,
                "P": self.p_summary,
                "O": self.o_summary,
            },
            "credences": self.credences,
            "threats": self.threats,
            "metadata": self.metadata,
        }

    def summary(self) -> str:
        """Generate a one-line summary."""
        theory_summaries = []
        for theory in self.theories:
            if theory in self.credences:
                post = self.credences[theory]["posterior"]
                theory_summaries.append(f"{theory}:[{post[0]:.2f},{post[1]:.2f}]")

        return f"{self.system_name} ({self.eval_date}): {' '.join(theory_summaries)}"
